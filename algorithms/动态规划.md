<!--
 * @Description: 
 * @Versions: 
 * @Author: Vernon Cui
 * @Github: https://github.com/vernon97
 * @Date: 2021-01-11 19:29:01
 * @LastEditors: Vernon Cui
 * @LastEditTime: 2021-01-11 19:34:02
 * @FilePath: /.leetcode/Users/vernon/Leetcode-notes/动态规划.md
-->
- [动态规划问题](#动态规划问题)
    - [1. 数字三角形模型](#1-数字三角形模型)
    - [2. 最长上升子序列模型](#2-最长上升子序列模型)
    - [3. 背包问题合集](#3-背包问题合集)
    - [4. 状态机模型](#4-状态机模型)
    - [5. 状态压缩DP](#5-状态压缩dp)
    - [6. 区间DP](#6-区间dp)
    - [7. 树形DP](#7-树形dp)
    - [8. 数位DP](#8-数位dp)
    - [9. 单调队列优化的DP问题](#9-单调队列优化的dp问题)

```diff
+ 感觉要写好久.. 但确实考的很多
```

# 动态规划问题

### 1. 数字三角形模型

### 2. 最长上升子序列模型

### 3. 背包问题合集

#### 3.1 0-1背包问题

状态表示：f[i, j]表示只能从前i个物品里选，总体积 <= j的方案

优化：只用到j - vi 一维数组 从右向左更新

```cpp
for(int i = 1; i <= n; i++)
    for(int j = m; j >= v[i]; j--){
        f[j] = max(f[j], f[j - v[i]] + w[i]);
    }
cout << f[m] << endl;
```

#### 3.2 完全背包问题

除了遍历顺序是从左到右，剩下和0-1背包问题完全一致

```cpp
for(int i = 1; i <= n; i++)
    for(int j = v[i]; j <= m; j++) {
        f[j] = max(f[j], f[j - v[i]] + w[i]);
    }
cout << f[m] << endl;
```

#### 3.3 多重背包问题

优化方式：二进制打包优化；

```cpp
while(T--) {
    int a, b, s;
    cin >> a >> b >> s;
    int k = 1;
    while(k <= s) {
        cnt ++;
        v[cnt] = a * k;
        w[cnt] = b * k;
        s -= k;
        k *= 2;
    }
}

n = cnt;
for(int i = 1; i <= n; i++) 
    for(int j = m; j >= v[i]; j--) {
        f[j] = max(f[j], f[j - v[i]] + w[i]);
    }
cout << f[m] << endl;
```

#### 3.4 分组背包问题

问题：分组，每组只能选一个 因此多了一个遍历组的过程 -> 组内0/1背包

```cpp
//s[i] 每个组有多少item，v[i][j], w[i][j], 

for(int i = 1; i <= n; i++)
    for(int j = m; j >= 0; j++){
        // 多了一步遍历组内item的过程
        for(int k = 0; k <= s[i]; k++)
        {
            if(j >= v[i][k]) f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);
        }
    }
cout << f[m] << endl;
```

#### 3.5 背包问题求具体方案

f[i, j] = max(f[i - 1, j], f[i - 1, j - v[i]] + w[i]);

最后输出f[n, m]

其实是判断每个物品是否备选，倒退出来再这个状态转移方程中，选择是的第一项还是第二项

具体区别：
1. 不能用状态压缩的方式 -> 两维状态循环无所谓
2. 判断f[n][m]倒退，判断是否从上一状态转移过来

0-1背包问题求方案：
（字典序最小-> 贪心的选（可选可不选，因为字典序最小，就要选）

```cpp
for(int i = 1; i <= n; i++)
    for(int j = 0; j <= m; j++) {
        f[i][j] = f[i - 1][j];
        if(j >= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
    }
// 输出方案
int j = m;
for(int i = n; i >= 1; i--)
{
    if(j >= v[i] && f[i][v] == f[i - 1][j - v[i]] + w[i]){
        cout << i << ' ';
        j -= v[i];
    }
}
```

#### 3.6 背包问题求方案数

最优解的方案数 -> 有点像路径条数

f[i, j] 

新开一个g[i, j] f[i, j] 取最大值的方案数

分三种情况：
- f[i - 1, j] 大 g[i - 1][j]
- f[i - 1, j - v[i]] + w[i] 大, g[i - 1, j - v[i]]
- 相等：两个想加

-> 可以用一维来写

```cpp
    for(int i = 0; i <= m; i ++)  cnt[i] = 1;

    for(int i = 1; i <= n; i ++) {
        int v, w;
        scanf("%d%d", &v, &w);
        for(int j = m; j >= v; j --) {
            int value = f[j - v] + w;
            if(value > f[j]) {
                f[j] = value;
                cnt[j] = cnt[j - v];
            } else if(value == f[j]) {
                cnt[j] = (cnt[j] + cnt[j - v]) % mod;
            }
        }
    }
``` 

### 4. 状态机模型

### 5. 状态压缩DP

### 6. 区间DP

### 7. 树形DP

### 8. 数位DP

### 9. 单调队列优化的DP问题


