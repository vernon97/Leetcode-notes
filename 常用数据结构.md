<!--
 * @Description: 
 * @Versions: 
 * @Author: Vernon Cui
 * @Github: https://github.com/vernon97
 * @Date: 2021-01-12 22:14:13
 * @LastEditors: Vernon Cui
 * @LastEditTime: 2021-01-25 22:26:07
 * @FilePath: /.leetcode/Users/vernon/Leetcode-notes/常用数据结构.md
-->
- [常用数据结构](#常用数据结构)
  - [1. 单调栈 / 单调队列](#1-单调栈--单调队列)
    - [1. 单调栈](#1-单调栈)
    - [2. 单调队列](#2-单调队列)
  - [2. 并查集](#2-并查集)
    - [1. 朴素并查集](#1-朴素并查集)
    - [2. 维护size的并查集](#2-维护size的并查集)
    - [3. 维护到祖宗节点距离的并查集](#3-维护到祖宗节点距离的并查集)
    - [4. 拓展域并查集](#4-拓展域并查集)
    - [5. 带权并查集](#5-带权并查集)
  - [3. 双链表](#3-双链表)
  - [4. 树状数组](#4-树状数组)
  - [5. 线段树](#5-线段树)
  - [6. treap](#6-treap)
  - [7. 可持久化数据结构](#7-可持久化数据结构)
  - [8. Trie 树 （可删除）](#8-trie-树-可删除)
  - [9. KMP](#9-kmp)
  - [10. 字符串哈希](#10-字符串哈希)
  - [11. STL 常用数据结构](#11-stl-常用数据结构)
## 常用数据结构

过于基础的就不提了，主要记一下算法题里面会用到的, 从应用场景记;

### 1. 单调栈 / 单调队列

#### 1. 单调栈

**单调栈:** 给定一个序列，求序列中`左边/右边`离它最近的且比它`小/大`的数

以找出每个数左边离他最近的比它小的数为例

```cpp
stack<int> stk;
vector<int> res;
for(int i = 0; i < nums.size(); i++)
{
    while(stk.size() && stk.top() >= nums[i]) stk.pop();
    // 此时栈顶元素 (如果有) 就是左边第一个比nums[i]小的数
    stack.push(nums[i]);
}
```

#### 2. 单调队列

**单调队列:** 滑动窗口的最值

记住单调队列存的是**下标** 方便判断是否已经划出窗口

```cpp
int hh = 0, tt = -1;
for(int i = 0; i < n; i++)
{
    if(hh <= tt && q[hh] < i - k + 1) hh++; // 判断对头是否划出窗口;
    while(hh <= tt && nums[q[tt]] >= nums[i]) tt--;
    // 区间最小值就是队头元素
    q[++tt] = i;
}
```

### 2. 并查集

并查集可以说代码短又好用第一名，我们记的都是带路径压缩的并查集

#### 1. 朴素并查集

```cpp
int p[N];
// 并查集别忘了初始化
for(int i = 1; i <= n; i++)
    p[i] = i;

int find(int x)
{
    if(p[x] != x)
        p[x] = find(p[x]);
    return p[x];
}
// 合并两个集合
p[find(a)] = find(b);
```

#### 2. 维护size的并查集

这里注意 只有每个集合root的size才有意义哦！

```cpp
int p[N], size[N];

int find(int x)
{
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
}
for(int i = 1; i <= n; i++)
    p[i] = i, size[i] = 1;

// 合并两个集合；-> root 变为 b
size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```

#### 3. 维护到祖宗节点距离的并查集

```cpp
int p[N], d[N];
//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离

// 返回x的祖宗节点
int find(int x)
{
    if (p[x] != x)
    {
        int u = find(p[x]);
        d[x] += d[p[x]];
        p[x] = u;
    }
    return p[x];
}

// 初始化，假定节点编号是1~n
for (int i = 1; i <= n; i ++ )
{
    p[i] = i;
    d[i] = 0;
}

// 合并a和b所在的两个集合：
p[find(a)] = find(b);
d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量
```
#### 4. 拓展域并查集

#### 5. 带权并查集

### 3. 双链表

### 4. 树状数组

### 5. 线段树

### 6. treap

### 7. 可持久化数据结构

### 8. Trie 树 （可删除）

### 9. KMP

### 10. 字符串哈希

### 11. STL 常用数据结构