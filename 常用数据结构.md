<!--
 * @Description: 
 * @Versions: 
 * @Author: Vernon Cui
 * @Github: https://github.com/vernon97
 * @Date: 2021-01-12 22:14:13
 * @LastEditors: Vernon Cui
 * @LastEditTime: 2021-01-28 18:06:51
 * @FilePath: /.leetcode/Users/vernon/Leetcode-notes/常用数据结构.md
-->
- [常用数据结构](#常用数据结构)
  - [1. 单调栈 / 单调队列](#1-单调栈--单调队列)
    - [1. 单调栈](#1-单调栈)
    - [2. 单调队列](#2-单调队列)
  - [2. 并查集](#2-并查集)
    - [1. 朴素并查集](#1-朴素并查集)
    - [2. 维护size的并查集](#2-维护size的并查集)
    - [3. 维护到祖宗节点距离的并查集](#3-维护到祖宗节点距离的并查集)
    - [4. 拓展域并查集](#4-拓展域并查集)
    - [5. 带权并查集](#5-带权并查集)
  - [3. 双链表](#3-双链表)
  - [4. 树状数组](#4-树状数组)
    - [1. 树状数组原理](#1-树状数组原理)
    - [2. 树状数组 + 差分](#2-树状数组--差分)
  - [5. 线段树](#5-线段树)
  - [6. treap](#6-treap)
  - [7. 可持久化数据结构](#7-可持久化数据结构)
  - [8. Trie 树 （可删除）](#8-trie-树-可删除)
  - [9. KMP](#9-kmp)
  - [10. 字符串哈希](#10-字符串哈希)
  - [11. 前缀和与差分](#11-前缀和与差分)
    - [1. 前缀和](#1-前缀和)
    - [2. 差分](#2-差分)
  - [12. STL 常用数据结构](#12-stl-常用数据结构)
## 常用数据结构

过于基础的就不提了，主要记一下算法题里面会用到的, 从应用场景记;

### 1. 单调栈 / 单调队列

#### 1. 单调栈

**单调栈:** 给定一个序列，求序列中`左边/右边`离它最近的且比它`小/大`的数

以找出每个数左边离他最近的比它小的数为例

```cpp
stack<int> stk;
vector<int> res;
for(int i = 0; i < nums.size(); i++)
{
    while(stk.size() && stk.top() >= nums[i]) stk.pop();
    // 此时栈顶元素 (如果有) 就是左边第一个比nums[i]小的数
    stack.push(nums[i]);
}
```

#### 2. 单调队列

**单调队列:** 滑动窗口的最值

记住单调队列存的是**下标** 方便判断是否已经划出窗口

```cpp
int hh = 0, tt = -1;
for(int i = 0; i < n; i++)
{
    if(hh <= tt && q[hh] < i - k + 1) hh++; // 判断对头是否划出窗口;
    while(hh <= tt && nums[q[tt]] >= nums[i]) tt--;
    // 区间最小值就是队头元素
    q[++tt] = i;
}
```

### 2. 并查集

并查集可以说代码短又好用第一名，我们记的都是带路径压缩的并查集

#### 1. 朴素并查集

```cpp
int p[N];
// 并查集别忘了初始化
for(int i = 1; i <= n; i++)
    p[i] = i;

int find(int x)
{
    if(p[x] != x)
        p[x] = find(p[x]);
    return p[x];
}
// 合并两个集合
p[find(a)] = find(b);
```

#### 2. 维护size的并查集

这里注意 只有每个集合root的size才有意义哦！

```cpp
int p[N], size[N];

int find(int x)
{
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
}
for(int i = 1; i <= n; i++)
    p[i] = i, size[i] = 1;

// 合并两个集合；-> root 变为 b
size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```

#### 3. 维护到祖宗节点距离的并查集

```cpp
int p[N], d[N];
//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离

// 返回x的祖宗节点
int find(int x)
{
    if (p[x] != x)
    {
        int u = find(p[x]);
        d[x] += d[p[x]];
        p[x] = u;
    }
    return p[x];
}

// 初始化，假定节点编号是1~n
for (int i = 1; i <= n; i ++ )
{
    p[i] = i;
    d[i] = 0;
}

// 合并a和b所在的两个集合：
p[find(a)] = find(b);
d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量
```
#### 4. 拓展域并查集

#### 5. 带权并查集

### 3. 双链表

### 4. 树状数组

#### 1. 树状数组原理
树状数组(FenwickTree) 的场景: 快速求前缀和 + 单点修改（修改数组其中某一个数） 这两个操作都是`o(logn)`

![avatar](figs/60.jpg)
![avatar](figs/61.jpg)

很重要一个性质：`parent(i) = i + lowbit(i)`

**1. 单点更新**

记住 记住 这里更新的是**差值：新值 - 原值**

```cpp
int lowbit(int i)
{
    return i & (-i);
}

void update(int i, int val)
{
    while(i <= len)
    {
        tree[i] += val;
        i += lowbit(i);
    }
}
```

**2. 求前缀和**

```cpp
int query(int i)
{
    int sum = 0;
    while(i > 0)
    {
        sum += tree[i];
        i -= lowbit(i);
    }
}
```

#### 2. 树状数组 + 差分



### 5. 线段树

### 6. treap

### 7. 可持久化数据结构

### 8. Trie 树 （可删除）

### 9. KMP

### 10. 字符串哈希

### 11. 前缀和与差分

#### 1. 前缀和
场景：快速求区间和

1. 一维前缀和
    `S[i] = a[1] + a[2] + ... a[i]`
    `a[l] + ... + a[r] = S[r] - S[l - 1]`
2. 二维前缀和
    `S[i, j]` = 第i行j列格子左上部分所有元素的和
    以`(x1, y1)`为左上角，`(x2, y2)`为右下角的子矩阵的和为：
    `S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]`

#### 2. 差分

1. 一维差分
   
场景：多次使区间`[l, r]`中的每个元素同时增加or减少`k`

差分实际上是前缀和的逆运算 构建数组`b`使得 `b`的前缀和数组等于`a`

给区间`[l, r]`中的每个数加上`c`：`B[l] += c`, `B[r + 1] -= c`

```cpp
int n, m;
int s[N], b[N];

void insert(int l, int r, int c)
{
    b[l] += c;
    b[r + 1] -= c;
}
int main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i++)
        cin >> s[i];
    // 初始化差分数组
    for(int i = 1; i <= n; i++)
    {
        // b[i] = s[i] - s[i - 1];
        insert(i, i, s[i]);
    }
    while(m--)
    {
        int l, r, c;
        cin >> l >> r >> c;
        insert(l, r, c);
    }
    // 恢复原数组
    for(int i = 1; i <= n; i++)
    {
        b[i] += b[i - 1];
        cout << b[i] << ' ';
    }
    cout << endl;
    return 0;
}
```
2. 二维差分

给以`(x1, y1)`为左上角，`(x2, y2)`为右下角的子矩阵中的所有元素加上`c`：
`S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c`

### 12. STL 常用数据结构